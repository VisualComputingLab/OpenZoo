<!DOCTYPE html>
<html>

    <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <link href='https://fonts.googleapis.com/css?family=Architects+Daughter' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="http://visualcomputinglab.github.io/OpenZoo/stylesheets/stylesheet.css" media="screen">
    <link rel="stylesheet" type="text/css" href="http://visualcomputinglab.github.io/OpenZoo/stylesheets/github-light.css" media="screen">
    <link rel="stylesheet" type="text/css" href="http://visualcomputinglab.github.io/OpenZoo/stylesheets/print.css" media="print">
    <link rel="stylesheet" href="http://visualcomputinglab.github.io/OpenZoo/fonts/font-awesome-4.4.0/css/font-awesome.min.css">


    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->

    <title>Openzoo by VisualComputingLab</title>
  </head>



  <body>

        <header>
      <div class="inner">
        <h1>Openzoo</h1>
        <h2>A framework for distributed stream/batch processing</h2>
        <a href="https://github.com/VisualComputingLab/OpenZoo" class="button" target="_ext"><small>View project on</small> GitHub</a>
      </div>
    </header>


    <div id="content-wrapper">
      <div class="inner clearfix">
        <section id="main-content">

          <h1>How it works</h1>

<p>All framework services inherit a basic OpenZoo service, which almost automates the communication with RedisIO, RabbitMQ, MongoDB and the outer world.</p>

<h2>Overview</h2>

<p>The standard way of achieving a simple task is the creation of one component, that runs on a single PC and completes the task.
In todays Big Data use cases, this is, of course, not an acceptable solution.
For achieving a complex stream/batch processing task, a service topology needs to be defined.
A topology is a set of services, each of them accomplishing a single subtask, in a Devide &amp; Conquer manner.
The services are interconnected in a predefined way, in order to exchange information.
Apart from that, each service may have, not one, but several instances, doing the same thing.</p>

<p><img src="../images/MultiInstance.png" alt="Several instances read from a queue and write to another queue" /></p>

<p>Assuming that the input can be divided in small pieces, that can be processed in parallel, this behaviour massively speeds up the procedure.
This can be done for every service in a topology.</p>

<p>In OpenZoo, services are built as depicted:</p>

<p><img src="../images/OZComponent.png" alt="OpenZoo Component" /></p>

<p>In the sequel, the terms service and component will be used interchangeably.
The service is living in a Tomcat container.
It can be started, stopped, resetted and queried over a web interface.
The service contains a worker, that does the actual job.
Several identical worker threads can be created for the same service (on the same server), so that the server resources are fully utilized.
Also several instances of the service can be deployed, each on a different server.
The instances may be identical or each instance may be dedicated to a specific type of input.
The topology is the predefined way of exchanging information between different services.
Below, a typical data ingestion topology is depicted:</p>

<p><img src="../images/TypicalIngestion.png" alt="Typical ingestion topology" /></p>

<p>The crawler introduces content into the system, comming either from the web or the filesystem.
Several instances of the metadata extractor, working in parallel, process the content.
The indexer indexes some of the produced metadata and the database manager stores everything in the database.
Also, a typical search topology follows:</p>

<p><img src="../images/TypicalSearch.png" alt="Typical search topology" /></p>

<p>A request broker, receives requests (queries) from the user application and forwards them into the system.
The query is received by an arbitrary index instance (in case of several copies of the same index) or by the appropriate index instance (in case of a distributed index) and a result list is produced.
The database manager enriches the results with the stored metadata and the final result list is returned to the broker, which answers the request.</p>

<p>Of course, the last two topologies can be merged to one, which will simultaneously ingest content and answer requests about it.</p>

<h2>Basic service parts</h2>

<p>In order to automate the service creation and the information exchange in the system, a basic service has been developed, from which all OpenZoo services inherit.
The main parts of each component are the following:</p>

<ul>
<li>A REST class, as an endpoint for web requests (GET, POST, etc.).</li>
<li>A Service class, responsible for starting, stopping and managing worker threads.</li>
<li>A Worker class, containing the actual code. Each worker can have zero or one input endpoint and zero or more output endpoints.</li>
</ul>


<p>The service template enables also the following:</p>

<ul>
<li>Reading topology parameters (server addresses, routing information, instantiation, etc.) from the RedisIO</li>
<li>Exchanging service specific parameters through RedisIO</li>
<li>Writing service statistics to the RedisIO</li>
</ul>


<h2>Service types</h2>

<p>As already depicted in the previous examples, there are two types of services.
The operator is a pure service, that receives input from a queue (or from the web/filesystem, in case of a crawler) and writes output to another queue (or to a database in case of a database manager).
It cannot communicate with the application user.
It has to have at least one endpoint: an input or an output.
Also, it can have several instances and several worker threads per instance.</p>

<p>The broker is a more sophisticated service, which accepts requests from the user application, forwards them to the system and waits for responses.
As soon as a response is received, it is forwarded to the user application.
It has to have at least one input endpoint and one output endpoint.
Finally, there should be only one instance of it, with just one worker thread.</p>

<h2>Service web interfaces</h2>

<p>All services accept a GET request with an action parameter:
The action can be one of start/stop/reset/status and forces the service to do exactly that.</p>

<p>Broker services accept also a POST request, for posting queries and and returning the response.
The POST body should be an application specific JSONObject.</p>

<h2>Communication format</h2>

<p>The common communication format for the whole framework is JSON.
All JSON messages have the following structure:
_id: string: a unique message id
header: JSONObject: intended for routing information, not application specific parameters
payload: JSONObject: application specific information. Structure defined by service.
log: JSONArray: Each component, which processed the message, leaves its signature here.
Each record has the following structure:
compId: String: unique name of component
instId: String: component instance id
workId: String: worker class
epInId: String: input endpoint id: optional
epOutId: String output endpoint id: optional
success: boolean: was processing successful?
start: long: epoch timestamp, starting millisecond
end: long: epoch timestamp, ending millisecond</p>

<p>Even binary data can be added to the payload, through the appropriate function, although it is not recommended to exchange large binary files through the queues.</p>

<p>A routing key can be added to the message.</p>

<p>The logging information is added automatically.</p>

<h2>Service endpoints</h2>

<p>3 types of endpoints exist:</p>

<ul>
<li>Input endpoint</li>
</ul>


<p>Accept input from the queue. It has the following interfaces:</p>

<pre><code>- public Message getNext(): Blocking function, which returns the next message from queue.
- public boolean ack(Message msg): Acknowledge a message received from the queue. The acknowledgment should happen after the message processing.
</code></pre>

<ul>
<li>Output endpoint</li>
</ul>


<p>Post message to the queue. It has the following interface:</p>

<pre><code>- public void put(Message msg): Post message to the queue.
</code></pre>

<ul>
<li>Logging endpoints</li>
</ul>


<p>Posts logging information to a dedicated queue. It has the following interfaces:</p>

<pre><code>- public void info(String logmessage): Post informational message.
- public void error(String logmessage): Post error message.
- public void debug(String logmessage): Post debugging information.
</code></pre>

<p>All 3 endpoint types need to be initialized through calling:</p>

<pre><code>- public boolean init()
</code></pre>

<h2>Worker interfaces</h2>

<p>All workers inherit the following overridable interfaces:</p>

<ul>
<li>public void run()</li>
</ul>


<p>Contains the endpoint initialization and the main worker loop, where messages are received, processed and posted.</p>

<ul>
<li>public boolean doWork(Message message)</li>
</ul>


<p>Contains the actual code for processing a message.</p>

<ul>
<li>public String publish(JSONObject obj)</li>
</ul>


<p>For broker services, contains the preparation and posting of a query received from the user application. It returns a hash value of the object as a receipt, for a later retrieval of the results.</p>

<p>Also, the following interfaces are inherited:</p>

<ul>
<li>public JSONObject getResponse(String hash, int timeout)</li>
</ul>


<p>Retrieves the query results, using the receipt from the publish call.</p>

<ul>
<li>public String getRequiredParameter(String param)</li>
</ul>


<p>Reads a parameter from the RedisIO.</p>


        </section>

                <aside id="sidebar">
          <a href="http://visualcomputinglab.github.io/OpenZoo/index.html" style="font-size: 16px;">
            <i class="fa fa-map-signs fa-2x fa-fw"></i>
            Overview
          </a>
          <hr>
          <a href="http://visualcomputinglab.github.io/OpenZoo/api" style="font-size: 16px;">
            <i class="fa fa-object-ungroup fa-2x fa-fw"></i>
            How it works
          </a>
          <hr>
          <a href="http://visualcomputinglab.github.io/OpenZoo/install" style="font-size: 16px;">
            <i class="fa fa-wrench fa-2x fa-fw"></i>
            Installation
          </a>
          <hr>
          <a href="http://visualcomputinglab.github.io/OpenZoo/demo" style="font-size: 16px;">
            <i class="fa fa-cogs fa-2x fa-fw"></i>
            Demo
          </a>
          <hr>
          <a href="http://visualcomputinglab.github.io/OpenZoo/future" style="font-size: 16px;">
            <i class="fa fa-lightbulb-o fa-2x fa-fw"></i>
            Future work
          </a>
          <hr>
          <a href="https://github.com/VisualComputingLab/OpenZoo/zipball/master" class="button">
            <small>Download</small>
            .zip file
          </a>
          <a href="https://github.com/VisualComputingLab/OpenZoo/tarball/master" class="button">
            <small>Download</small>
            .tar.gz file
          </a>
        </aside>


      </div>
    </div>

        <footer>
      <hr>
      <div class="center">
        <p style="text-align: center;">
          maintained by <a href="http://vcl.iti.gr" target="_ext">Visual Computing Lab</a>
          <br>
          <a href="http://www.iti.gr" target="_ext">@ITI</a>  <a href="http://www.certh.gr/root.en.aspx" target="_ext">@CERTH</a>
        </p>
      </div>
    </footer>

    <script type="text/javascript">
      var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
      document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
    </script>

    <script type="text/javascript">
      try {
        var pageTracker = _gat._getTracker("UA-69836989-1");
        pageTracker._trackPageview();
      } catch(err) {}
    </script>


  </body>
</html>
